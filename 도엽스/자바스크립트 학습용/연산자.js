/* 연산자의 우선순의. 연산자가 여러 개 있을 때는 계산 순서에 따라 결과가 달라진다. */
2 + 3 * 4; // -> 14
(2 + 3) * 4; // -> 20
/* 연산자의 우선순의가 같을 땐 왼쪽에서 오른쪽으로 */
(24 / 6) * 2; // -> 8

/* 연산자의 부수 효과 라는게 있다. 예를들어 x + y 표현식은 변수 값을 바꾸지는 않지만, x = y처럼 대입하는 표현식은 변수 x 값을 바꾼다. 이처럼 변수 값을 바꾸는 표현식은 일반적으로 부수 효과가 있는 표현식이라고 한다. 대입 연산자, 증가 연산자, 감소 연산자, delete가 부수 효과가 있는 연산자다. 나머지 연산자에는 모두 부수 효과가 없다 */

/* 산술 연산자. 산술 연산자는 피연산자가 숫자인 연산자다. 피연산자가 숫자가 아닐 때는 연산자가 피연산자 타입을 숫자 타입으로 바꾸어 연산한다. 연산 결과로는 숫자 값이 나오지만 피연산자가 숫자로 바꿀 수 없는 값이거나 계산할 수 없을 때는 NaN이 나온다. 모든 산술 연산자는 64비트 부동소수점 연산으로 이루어진다. */
7 / 2; // -> 3.5
15 % 4; // -> 3

/* + 연산자는 피연산자가 숫자면 더하고 문자열이면 연결한다. 피연산자 중 하나가 숫자고 다른 하나가 문자열이면 숫자를 문자열로 타입을 바꾸고 문자열과 연결한다. */
1 + "2month"; // -> "12month"     숫자 1을 문자열 "1"로 타입을 바꾸고 "2month"와 연결한다.

/*계산할 수 없는 경우 NaN으로 평가한다. 또한 산술 연산자의 피연산자가 true면 1, false와 null이면 0으로 평가한다. undefined면 NaN으로 평가한다 */
0 / 0; // -> NaN   계산할 수 없음
"one" * 1; // -> NaN   계산할 수 없음
true + true; // -> 2   논리값의 타입을 숫자로 바꾸어 더함
1 + null; // -> 1   null을 0으로 바꾸어 더함
1 + undefined; // -> NaN   undefined를 NaN으로 바꾸어 더함

/* 산술 단항 연산자. 증가 연산자는 피연산자 값에 1을 더하고 감소 연산자는 피연산자 값에서 1을 뺀다. 모두가 부수 효과가 있는 연산자이며 피연산자는 좌변에 있어야 한다 */
++a; // -> 증가 연산자. a에 1을 더한 다음 a 값을 평가한다.
a++; // -> 증가 연산자. a를 평가한 다음에 a에 1을 더한다.
--a; // -> 감소 연산자. a에서 1을 뺀 다음에 a 값을 평가한다.
a-- + // -> 감소 연산자. a를 평가한 다음에 a에서 1을 뺀다.
  a - // -> a와 같은 값으로 평가한다.
  a; // -> a의 부호를 반전한 값으로 평가한다.

a = 1;
b = ++a; // -> b는 2가 되고 a는 2가 된다. (a에 1을 더하고 a를 b에 대입한다.)
c = a++ + 2; // -> c는 4가 되고 a는 3이 된다. (a + 2를 c에 대입하고 a에 1을 더한다)

/*증가 연산자 또는 감소 연산자를 연속으로 사용하면 참조 오류가 발생한다. */
a++++; // -> ReferenceError

/* 산술 대입 연산자 라는게 있다. */
a += b; //  -> a=a+b
a -= b; //  -> a=a-b
a *= b; //  -> a=a*b
a /= b; //  -> a=a/b
a %= b; //  -> a=a%b

/* + 연산자는 피연산자가 모두 문자열이면 문자열로 연결한다. */
"hello" + "world"; // -> "helloworld"
"1" + "2"; // -> "12"
/* 피연산자 중 하나가 문자열 또는 문자열로 변환할 수 있는 객체라면 다른 피연산자의 타입을 문자열로 바꾼 다음 연결한다 */
10 + "little indians"; // -> 10little indians
true + new Date(); // -> "trueMon Feb 22 2021 21:55:17 GMT+0900 (대한민국 표준시)"
/* 그렇지 않으면 피연산자 두 개를 숫자 또는 NaN으로 타입을 바꾸어 더한다. 단, 이 경우는 자바스크립트의 실행 환경에 따라 처리하는 방법이 다르다. */
var a = 3;
console.log("a 의 값은" + a + "인데 알아서 뭐하게");

/* 문자열을 처리하기 위한 객체로 String 객체가 마련되어 있다. 문자열을 String 객체로 변환하려면 String 생성자를 사용한다. */
var msgObj = new String("Everything is practice.");
console.log(msgObj);
/* 이처럼 원시 값을 변환하는 행위를 가리켜 원시 값을 객체로 래핑한다고 한다. String 객체에는 문자열을 처리하기 위한 다양한 프로퍼티와 매서드가 마련되어 있다. */

/* 예를 들어 문자열의 길이는 배열과 마찬가지로 length 프로퍼티로 구할 수 있다 */
msgObj.length; // -> 23
/* charAt 메서드를 이용하면 문자열의 n번째 문자를 구할 수 있다. */
msgObj.charAt(3); // -> r
/* 이러한 String 객체의 프로퍼티와 메서드는 문자열에서도 사용할 수 있다. */
var msg = "Everything is practice.";
console.log(msg.length);
console.log(msg.charAt(3));

/* 문자열은 객체가 아니므로 프로퍼티를 가지고 있지 않다. 그런데 이것이 어떻게 동작하는 걸까? 문자열에서 프로퍼티를 사용하려고 하면 문자열이 자동으로 String 객체로 변환대기 때문이다. 예를 들어 다음 코드를 실행한다고 합시다. */
var c = msg.charAt(3);  // 이 코드를 실행하면 내부적으로 다음과 같은 작업이 실행된다.
var msgObj = new String(msg);  // 문자열을 String 객체로 변환
var c = msgObj.charAt(3);  // String 객체의 메서드를 사용
/* 실제로 msgObj는 실행하는 순간에 일시적으로 생성되는 String 객체이므로 사용자에게는 보이지 않는다. 처리가 끝나면 곧바로 메모리에서 삭제된다. 이러한 객체를 가리켜 래퍼 객체라고 한다. 자바스크립트에서는 원시 값을 처리할 때 원시 값을 래퍼 객체로 자동 변환한다. 그리고 래퍼 객체의 기능을 활용해서 다양한 작업을 수행한다. 문자열은 String객체, 숫자는 Number 객체, 논리값은 Boolean 객체로 변환된다. 단 null과 undefined에는 래퍼 객체가 읎다. */

/* 써로게이트 라는 것 도 있으니 찾아봐라 */

/* 관계 연산자는 두 개의 피연산자를 비교한 결과를 논리값 (true/flase)으로 반환한다. 관계 연산자는 주로 제어 구조(if/else 문, while 문, do/while 문, for 문)에서 조건식을 만들 때 사용한다. */
== // -> 값이 같음
!= // -> 값이 다름
=== // -> 값과 타입이 같음
!== // -> 값과 타입이 다름
< // -> 작음
> // -> 큼
<= // -> 작거나 같음
>= // -> 크거나 같음

/* 값이 같으면 true, 다르면 false로 판정한다. 이 값의 의미는 변수의 데이터 타입에 따라 달라지는데 원시 타입 변수의 값과 객체 타입 변수의 값은 내용물이 다르기 때문이다.
원시 타입 변수의 값은 데이터 그 자체인데 반해 객체 타입 변수의 값은 객체의 참조라는 점이 다르다. 따라서 객체 타입 변수의 값이 같은지를 판별하는 행위는 같은 객체를 가리키는지를 판별하는 것과 같다. */
var a =[1,2,3];
var b = [1,2,3];
var c = a;
console.log(a==b); // -> false
console.log(a==c); // -> true
/* 변수 a와 b에는 모두 배열의 참조가 저장되어 있다. 각 배열에는 같은 데이터가 담겨있지만 메모리에서 차지하는 위치가 다르다. 따라서 a 값과 b 값이 다르다고 판정한다. */

