/* 연산자의 우선순의. 연산자가 여러 개 있을 때는 계산 순서에 따라 결과가 달라진다. */
2 + 3 * 4; // -> 14
(2 + 3) * 4; // -> 20
/* 연산자의 우선순의가 같을 땐 왼쪽에서 오른쪽으로 */
(24 / 6) * 2; // -> 8

/* 연산자의 부수 효과 라는게 있다. 예를들어 x + y 표현식은 변수 값을 바꾸지는 않지만, x = y처럼 대입하는 표현식은 변수 x 값을 바꾼다. 이처럼 변수 값을 바꾸는 표현식은 일반적으로 부수 효과가 있는 표현식이라고 한다. 대입 연산자, 증가 연산자, 감소 연산자, delete가 부수 효과가 있는 연산자다. 나머지 연산자에는 모두 부수 효과가 없다 */

/* 산술 연산자. 산술 연산자는 피연산자가 숫자인 연산자다. 피연산자가 숫자가 아닐 때는 연산자가 피연산자 타입을 숫자 타입으로 바꾸어 연산한다. 연산 결과로는 숫자 값이 나오지만 피연산자가 숫자로 바꿀 수 없는 값이거나 계산할 수 없을 때는 NaN이 나온다. 모든 산술 연산자는 64비트 부동소수점 연산으로 이루어진다. */
7 / 2; // -> 3.5
15 % 4; // -> 3

/* + 연산자는 피연산자가 숫자면 더하고 문자열이면 연결한다. 피연산자 중 하나가 숫자고 다른 하나가 문자열이면 숫자를 문자열로 타입을 바꾸고 문자열과 연결한다. */
1 + "2month"; // -> "12month"     숫자 1을 문자열 "1"로 타입을 바꾸고 "2month"와 연결한다.

/*계산할 수 없는 경우 NaN으로 평가한다. 또한 산술 연산자의 피연산자가 true면 1, false와 null이면 0으로 평가한다. undefined면 NaN으로 평가한다 */
0 / 0; // -> NaN   계산할 수 없음
"one" * 1; // -> NaN   계산할 수 없음
true + true; // -> 2   논리값의 타입을 숫자로 바꾸어 더함
1 + null; // -> 1   null을 0으로 바꾸어 더함
1 + undefined; // -> NaN   undefined를 NaN으로 바꾸어 더함

/* 산술 단항 연산자. 증가 연산자는 피연산자 값에 1을 더하고 감소 연산자는 피연산자 값에서 1을 뺀다. 모두가 부수 효과가 있는 연산자이며 피연산자는 좌변에 있어야 한다 */
++a; // -> 증가 연산자. a에 1을 더한 다음 a 값을 평가한다.
a++; // -> 증가 연산자. a를 평가한 다음에 a에 1을 더한다.
--a; // -> 감소 연산자. a에서 1을 뺀 다음에 a 값을 평가한다.
a-- + // -> 감소 연산자. a를 평가한 다음에 a에서 1을 뺀다.
  a - // -> a와 같은 값으로 평가한다.
  a; // -> a의 부호를 반전한 값으로 평가한다.

a = 1;
b = ++a; // -> b는 2가 되고 a는 2가 된다. (a에 1을 더하고 a를 b에 대입한다.)
c = a++ + 2; // -> c는 4가 되고 a는 3이 된다. (a + 2를 c에 대입하고 a에 1을 더한다)

/*증가 연산자 또는 감소 연산자를 연속으로 사용하면 참조 오류가 발생한다.
(ㅁ++)++ // -> ReferenceError   
