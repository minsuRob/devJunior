/* 연산자의 우선순의. 연산자가 여러 개 있을 때는 계산 순서에 따라 결과가 달라진다. */
2 + 3 * 4; // -> 14
(2 + 3) * 4; // -> 20
/* 연산자의 우선순의가 같을 땐 왼쪽에서 오른쪽으로 */
(24 / 6) * 2; // -> 8

/* 연산자의 부수 효과 라는게 있다. 예를들어 x + y 표현식은 변수 값을 바꾸지는 않지만, x = y처럼 대입하는 표현식은 변수 x 값을 바꾼다. 이처럼 변수 값을 바꾸는 표현식은 일반적으로 부수 효과가 있는 표현식이라고 한다. 대입 연산자, 증가 연산자, 감소 연산자, delete가 부수 효과가 있는 연산자다. 나머지 연산자에는 모두 부수 효과가 없다 */

/* 산술 연산자. 산술 연산자는 피연산자가 숫자인 연산자다. 피연산자가 숫자가 아닐 때는 연산자가 피연산자 타입을 숫자 타입으로 바꾸어 연산한다. 연산 결과로는 숫자 값이 나오지만 피연산자가 숫자로 바꿀 수 없는 값이거나 계산할 수 없을 때는 NaN이 나온다. 모든 산술 연산자는 64비트 부동소수점 연산으로 이루어진다. */
7 / 2; // -> 3.5
15 % 4; // -> 3

/* + 연산자는 피연산자가 숫자면 더하고 문자열이면 연결한다. 피연산자 중 하나가 숫자고 다른 하나가 문자열이면 숫자를 문자열로 타입을 바꾸고 문자열과 연결한다. */
1 + "2month"; // -> "12month"     숫자 1을 문자열 "1"로 타입을 바꾸고 "2month"와 연결한다.

/*계산할 수 없는 경우 NaN으로 평가한다. 또한 산술 연산자의 피연산자가 true면 1, false와 null이면 0으로 평가한다. undefined면 NaN으로 평가한다 */
0 / 0; // -> NaN   계산할 수 없음
"one" * 1; // -> NaN   계산할 수 없음
true + true; // -> 2   논리값의 타입을 숫자로 바꾸어 더함
1 + null; // -> 1   null을 0으로 바꾸어 더함
1 + undefined; // -> NaN   undefined를 NaN으로 바꾸어 더함

/* 산술 단항 연산자. 증가 연산자는 피연산자 값에 1을 더하고 감소 연산자는 피연산자 값에서 1을 뺀다. 모두가 부수 효과가 있는 연산자이며 피연산자는 좌변에 있어야 한다 */
++a; // -> 증가 연산자. a에 1을 더한 다음 a 값을 평가한다.
a++; // -> 증가 연산자. a를 평가한 다음에 a에 1을 더한다.
--a; // -> 감소 연산자. a에서 1을 뺀 다음에 a 값을 평가한다.
a-- + // -> 감소 연산자. a를 평가한 다음에 a에서 1을 뺀다.
  a - // -> a와 같은 값으로 평가한다.
  a; // -> a의 부호를 반전한 값으로 평가한다.

a = 1;
b = ++a; // -> b는 2가 되고 a는 2가 된다. (a에 1을 더하고 a를 b에 대입한다.)
c = a++ + 2; // -> c는 4가 되고 a는 3이 된다. (a + 2를 c에 대입하고 a에 1을 더한다)

/*증가 연산자 또는 감소 연산자를 연속으로 사용하면 참조 오류가 발생한다. */
a++++; // -> ReferenceError

/* 산술 대입 연산자 라는게 있다. */
a += b; //  -> a=a+b
a -= b; //  -> a=a-b
a *= b; //  -> a=a*b
a /= b; //  -> a=a/b
a %= b; //  -> a=a%b

/* + 연산자는 피연산자가 모두 문자열이면 문자열로 연결한다. */
"hello" + "world"; // -> "helloworld"
"1" + "2"; // -> "12"
/* 피연산자 중 하나가 문자열 또는 문자열로 변환할 수 있는 객체라면 다른 피연산자의 타입을 문자열로 바꾼 다음 연결한다 */
10 + "little indians"; // -> 10little indians
true + new Date(); // -> "trueMon Feb 22 2021 21:55:17 GMT+0900 (대한민국 표준시)"
/* 그렇지 않으면 피연산자 두 개를 숫자 또는 NaN으로 타입을 바꾸어 더한다. 단, 이 경우는 자바스크립트의 실행 환경에 따라 처리하는 방법이 다르다. */
var a = 3;
console.log("a 의 값은" + a + "인데 알아서 뭐하게");

/* 문자열을 처리하기 위한 객체로 String 객체가 마련되어 있다. 문자열을 String 객체로 변환하려면 String 생성자를 사용한다. */
var msgObj = new String("Everything is practice.");
console.log(msgObj);
/* 이처럼 원시 값을 변환하는 행위를 가리켜 원시 값을 객체로 래핑한다고 한다. String 객체에는 문자열을 처리하기 위한 다양한 프로퍼티와 매서드가 마련되어 있다. */

/* 예를 들어 문자열의 길이는 배열과 마찬가지로 length 프로퍼티로 구할 수 있다 */
msgObj.length; // -> 23
/* charAt 메서드를 이용하면 문자열의 n번째 문자를 구할 수 있다. */
msgObj.charAt(3); // -> r
/* 이러한 String 객체의 프로퍼티와 메서드는 문자열에서도 사용할 수 있다. */
var msg = "Everything is practice.";
console.log(msg.length);
console.log(msg.charAt(3));

/* 문자열은 객체가 아니므로 프로퍼티를 가지고 있지 않다. 그런데 이것이 어떻게 동작하는 걸까? 문자열에서 프로퍼티를 사용하려고 하면 문자열이 자동으로 String 객체로 변환대기 때문이다. 예를 들어 다음 코드를 실행한다고 합시다. */
var c = msg.charAt(3);  // 이 코드를 실행하면 내부적으로 다음과 같은 작업이 실행된다.
var msgObj = new String(msg);  // 문자열을 String 객체로 변환
var c = msgObj.charAt(3);  // String 객체의 메서드를 사용
/* 실제로 msgObj는 실행하는 순간에 일시적으로 생성되는 String 객체이므로 사용자에게는 보이지 않는다. 처리가 끝나면 곧바로 메모리에서 삭제된다. 이러한 객체를 가리켜 래퍼 객체라고 한다. 자바스크립트에서는 원시 값을 처리할 때 원시 값을 래퍼 객체로 자동 변환한다. 그리고 래퍼 객체의 기능을 활용해서 다양한 작업을 수행한다. 문자열은 String객체, 숫자는 Number 객체, 논리값은 Boolean 객체로 변환된다. 단 null과 undefined에는 래퍼 객체가 읎다. */

/* 써로게이트 라는 것 도 있으니 찾아봐라 */

/* 관계 연산자는 두 개의 피연산자를 비교한 결과를 논리값 (true/flase)으로 반환한다. 관계 연산자는 주로 제어 구조(if/else 문, while 문, do/while 문, for 문)에서 조건식을 만들 때 사용한다. */
== // -> 값이 같음
!= // -> 값이 다름
=== // -> 값과 타입이 같음
!== // -> 값과 타입이 다름
< // -> 작음
> // -> 큼
<= // -> 작거나 같음
>= // -> 크거나 같음

/* 좌우 피연산자의 타입이 같을 때 값이 같으면 true, 다르면 false로 판정한다. 이 값의 의미는 변수의 데이터 타입에 따라 달라지는데 원시 타입 변수의 값과 객체 타입 변수의 값은 내용물이 다르기 때문이다.
원시 타입 변수의 값은 데이터 그 자체인데 반해 객체 타입 변수의 값은 객체의 참조라는 점이 다르다. 따라서 객체 타입 변수의 값이 같은지를 판별하는 행위는 같은 객체를 가리키는지를 판별하는 것과 같다. */
var a =[1,2,3];
var b = [1,2,3];
var c = a;
console.log(a==b); // -> false
console.log(a==c); // -> true
/* 변수 a와 b에는 모두 배열의 참조가 저장되어 있다. 각 배열에는 같은 데이터가 담겨있지만 메모리에서 차지하는 위치가 다르다. 따라서 a 값과 b 값이 다르다고 판정한다. */

/* 좌우 피연산자의 타입이 다를 때는 두 피연산자가 같은 타입이 되도록 타입을 변환한 다음에 다음 규칙에 따라 동일한지 판별한다 */
  -undefined 와 null은 같은 것으로 친다
  -한쪽이 숫자고 다른 한쪽이 문자열이면 문자열을 숫자로 변환해서 비교한다.
  -둘 중에 한쪽이 논리값이면 true는 1, false는 0으로 변환해서 비교한다.
  -한쪽이 객체고 다른 한쪽이 숫자 또는 문자열이면 객체를 toString이나 valueof 메서드를 사용해서 원시 타입으로 변환한 다음에 비교한다.
  -앞의 규칙에서 벗어나면 모두 '같지 않음'으로 판정한다.
null == undefined // -> true
1 == "1" // -> true
"0xff" == 255 // -> true
true == 1 // -> true
true == "1" // -> true
(new String("a")) == "a" // -> true
(new Number(2)) == 2 // -> true
[2] == 2 // -> true

/* 일치 연산자는 피연산자를 평가한 후에 타입을 변환하지 않은 상태의 두 값을 엄격하게 비교한다. 타입과 값이 모두 같으면 같다고 판정하고 그렇지 않으면 같지 않다고 판정한다. 
단, NaN만큼은 NaN을 포함한 모든 값과 같지 않다고 판정한다. */
NaN === NaN; // -> false
/* NaN은 x !== x 를 만족하는 유일한 값임을 확인할 수 있다. 변수 값이 NaN인지는 isNaN 함수로도 확인할 수 있다. */

/* 동일 연산자의 사용 예에서는 true였던 표현식이 일치 연산자에서는 모두 false가 된다. */
null === undefined // -> false
1 === "1" // -> false
"0xff" === 255 // -> false
true === 1 // -> false
true === "1" // -> false
(new String("a")) === "a" // -> false
(new Number(2)) === 2 // -> false
[2] === 2 // -> false

/* 논리 연산자는 관계 연산자를 사용하여 만든 논리식과 결합하여 더욱 복잡한 논리를 정의한다. */
a && b // -> 논리곱 AND a와 b가 모두 true면 true. 그 외에는 false
a || b // -> 논리합 OR a와 b 중 하나라도 true면 true. 모두가 false면 false
a ! b // -> 부정 NOT a가 true면 false. false면 true
/* 예시 */
var x;
var y;
x = 1;
y = 0;
/*1*/x > 0 && y > 0; // -> false x와 y가 모두 참일 때만 true
/*2*/x > 0 || y > 0; // -> true x와 y 중 하나라도 참이면 true. 모두가 0 이하면 false
/*3*/!(a&&b) // -> a 또는 b가 거짓
/* 여기서 첫 번째 코드와 두 번째 코드는  관계 연산자의 우선순위가 논리 연산자보다 높기 때문에 괄호를 쓸 필요가 없지만 세 번째 코드에서는 !가 &&보다 우선순위가 높으므로 소괄호로 묶어야함 */

/* 단락 연산자 는 OR|| 연산자가 첫 번째 값이 참이라면 두 번째 값은 검사하지 않는 점을 이용한 정보 확인 방법이다. */
true || ture ; // -> true
true || false // -> true
const name = '도엽' || '유완';
console.log(name); // -> 도엽

/* 단락 평가는 주로 코드를 간결하게 만들 때 사용한다 */
(참/거짓 여부를 판별할 대상) || (기본값)

