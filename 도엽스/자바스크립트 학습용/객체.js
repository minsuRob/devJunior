let card = { suit: "하트", rank: "A" }; // {...} 부분이 '객체 리터럴'.  suit : "하트" 와 rank : "A" 에서 suit : "하트", rank : "A" 가 각각 '프로퍼티' 라고 함. suit 랑 rank가 '프로퍼티 이름', 하트 랑 A 가 '프로퍼티 값'
let card = {
  suit: "하트",
  rank: "A",
}; //이처럼 프로퍼티 이름에는 모든 식별자와 문자열 리터럴을 사용 가능. 프로퍼티 값은 모든 데이터 타임의 값과 표현식을 대입할 수 있음

/* 변수에 대입된 객체 안의 프로퍼티 값을 읽거나 쓸 때는 마침표(.) 연산자 또는 대괄호 연산자를 사용 */
card.suit; // -> 하트 를 출력
card["rank"]; // -> A 를 출력

card.value = 14; //없는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가됨.
console.log(card);

delete card.rank; //delete 연산자를 사용하면 프로퍼티를 삭제 가능
console.log(card);

console.log("suit" in card); //in 연산자를 사용하면 객체에 특정 프로퍼티가 있는지 확인할 수 있음

/* 생성된 객체는 메모리의 영역을 차지하는 한 덩어리가 된다. 객체 타입의 값을 변수에 대입하면 그 변수에는 객체의 참조가 저장된다. 이때의 변수 상태를 가리켜 그 객체를 참조하고 있다라고 함.
변수 card에 트럼프 카드 객체의 참조가 저장되어 있음을 표현한 것. */
let a = card; //변수에 저장된 객체의 참조는 다른 원시 값과 마찬가지로 다른 변수에 저장할 수 있다. 그러면 변수 a가 card 객체를 참조하게 되므로 a로 card 객체를 읽거나 수정 가능
console.log(a.suit); // -> 하트 를 출력
a.suit = "스페이드"; // suit 라는 프로퍼티 이름에 대한 프로퍼티 값을 스페이드로 대입
console.log(a.suit); // -> 스페이드 출력
console.log(card.suit); // 변수 card와 a가 같은 객체를 참조하기 때문에 위의 문장에서 함께 변경됨. 스페이드 출력

/* Java 와 C++ 등은 프로퍼티를 갖는 객체를 여러 개 생성하는 수단으로 클래서(class)를 제공한다. 클래스는 붕어빵 틀에 비유할 수 있다. 붕어빵 틀을 사용하면 모양이 같은 붕어빵을 얼마든지 만들 수 있다. 붕어빵 틀과 마찬가지로 클래스를 사용하면 프로퍼티가 똑같은 객체를 얼마든지 만들 수 있다. */ \;
/* 하지만 자바스크립트에는 클래스가 없다. 대신 생성자라고 하는 함수로 객체를 생성할 수 있다. */
/* 다음 코드는 트럼프 카드를 표현하는 객체를 생성하는 생성자이다 */
function Card(suit, rank) {
  this.suit = suit;
  this.rank = rank;
}
/* 생성자로 객체를 생성할 때는 new 연산자를 사용한다. */
var card = new Card("하트", "A");
/* 이 코드를 실행하면 suit 프로퍼티에는 "하트", rank 프로퍼티에넌 "A"라는 값이 저장된 객체가 생성되고, 마지막으로 그 객체의 참조가 변수 card에 할당된다. */
console.log(card); // -> Card {suit: "하트", rank"A"}
/* 이때 Card 생성자로 생성한 객체를 Card 객체라고 부른다. console.log로 객체를 출력하면 앞에 생성자 이름이 표시된다. */

/* 앞의 예처럼 new연산자로 객체를 생성할 것이라고 기대하고 만든 함수를 생성자라고 부른다. 생성자 이름은 관례적으로 그것이 생성자임을 알리기 위해 첫 글자를 대문자로 쓰는 파스칼 표기법을 사용한다. */
/*이건 뭔 개소리여 */
