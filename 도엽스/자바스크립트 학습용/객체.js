let card = { suit: "하트", rank: "A" }; // {...} 부분이 '객체 리터럴'.  suit : "하트" 와 rank : "A" 에서 suit : "하트", rank : "A" 가 각각 '프로퍼티' 라고 함. suit 랑 rank가 '프로퍼티 이름', 하트 랑 A 가 '프로퍼티 값'
let card = {
  suit: "하트",
  rank: "A",
}; //이처럼 프로퍼티 이름에는 모든 식별자와 문자열 리터럴을 사용 가능. 프로퍼티 값은 모든 데이터 타임의 값과 표현식을 대입할 수 있음

/* 변수에 대입된 객체 안의 프로퍼티 값을 읽거나 쓸 때는 마침표(.) 연산자 또는 대괄호 연산자를 사용 */
card.suit; // -> 하트 를 출력
card["rank"]; // -> A 를 출력

card.value = 14; //없는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가됨.
console.log(card);

delete card.rank; //delete 연산자를 사용하면 프로퍼티를 삭제 가능
console.log(card);

console.log("suit" in card); //in 연산자를 사용하면 객체에 특정 프로퍼티가 있는지 확인할 수 있음

/* 생성된 객체는 메모리의 영역을 차지하는 한 덩어리가 된다. 객체 타입의 값을 변수에 대입하면 그 변수에는 객체의 참조가 저장된다. 이때의 변수 상태를 가리켜 그 객체를 참조하고 있다라고 함.
변수 card에 트럼프 카드 객체의 참조가 저장되어 있음을 표현한 것. */
let a = card; //변수에 저장된 객체의 참조는 다른 원시 값과 마찬가지로 다른 변수에 저장할 수 있다. 그러면 변수 a가 card 객체를 참조하게 되므로 a로 card 객체를 읽거나 수정 가능
console.log(a.suit); // -> 하트 를 출력
a.suit = "스페이드"; // suit 라는 프로퍼티 이름에 대한 프로퍼티 값을 스페이드로 대입
console.log(a.suit); // -> 스페이드 출력
console.log(card.suit); // 변수 card와 a가 같은 객체를 참조하기 때문에 위의 문장에서 함께 변경됨. 스페이드 출력

/* Java 와 C++ 등은 프로퍼티를 갖는 객체를 여러 개 생성하는 수단으로 클래서(class)를 제공한다. 클래스는 붕어빵 틀에 비유할 수 있다. 붕어빵 틀을 사용하면 모양이 같은 붕어빵을 얼마든지 만들 수 있다. 붕어빵 틀과 마찬가지로 클래스를 사용하면 프로퍼티가 똑같은 객체를 얼마든지 만들 수 있다. */ \;
/* 하지만 자바스크립트에는 클래스가 없다. 대신 생성자라고 하는 함수로 객체를 생성할 수 있다. */
/* 다음 코드는 트럼프 카드를 표현하는 객체를 생성하는 생성자이다 */
function Card(suit, rank) {
  this.suit = suit;
  this.rank = rank;
}
/* 생성자로 객체를 생성할 때는 new 연산자를 사용한다. */
var card = new Card("하트", "A");
/* 이 코드를 실행하면 suit 프로퍼티에는 "하트", rank 프로퍼티에넌 "A"라는 값이 저장된 객체가 생성되고, 마지막으로 그 객체의 참조가 변수 card에 할당된다. */
console.log(card); // -> Card {suit: "하트", rank"A"}
/* 이때 Card 생성자로 생성한 객체를 Card 객체라고 부른다. console.log로 객체를 출력하면 앞에 생성자 이름이 표시된다. */

/* 앞의 예처럼 new연산자로 객체를 생성할 것이라고 기대하고 만든 함수를 생성자라고 부른다. 생성자 이름은 관례적으로 그것이 생성자임을 알리기 위해 첫 글자를 대문자로 쓰는 파스칼 표기법을 사용한다. */
/* 생성자 안에서 this.프로퍼티 이름에 값을 대입하면 그 이름을 가진 프로퍼티에 값이 할당된 객체가 생성된다. 이때 this는 생성자가 생성하는 객체를 가리킨다. 앞의 예는 다음과 같이 객체 리터럴로 고쳐쓸 수 있다 */
var card = {};
card.suit = "하트";
card.rank = "A";
/* 생성자와 new 연산자로 생성한 객체를 그 생성자의 인스턴스라고 부른다. 인스턴스에는 실체 라는 뜻이 있다. */

/* 생성자는 객체를 생성하고 초기화하는 역할을 한다. 생성자를 사용하면 이름은 같지만 프로퍼티 값이 다른 객체(인스턴스) 여러 개를 간단히 생성할 수 있다. */
var card1 = Card{"하트", "A"};
var card2 = Card{"클로버", "K"};
var card3 = Card{"스페이드", "2"};
/* 이처럼 생성자를 사용하면 이름은 같지만 프로퍼티 값이 다른 객체 여러개를 효율적으로 생성할 수 있다. */

/* 자바스크립트에는 처음부터 사용할 수 있는 내장 객체(빌트인 오브젝트)가 마련되어있다. 내장 객체는 자바스크립트라는 프로그래밍 언어의 뼈대를 구성한다. */ 
/*Date 생성자는 날짜와 시간을 표현하는 객체를 생성한다. Date 객체에 내장된 다양한 메서드를 활용하면 날짜와 시간 처리를 간단하게 할 수 있다. Date 객체는 Date 생성자로 생성한다 */
var now = new Date();
/*앞 문장을 실행하면 실행한 시점의 날짜와 시간 정보를 담은 객체를 생성하고, 그 객체의 참조를 변수 now에 대입한다. console.log 를 사용하면 Date 객체의 날짜와 시간 정보를 볼 수 있다 */
console.log (now); // -> Tue Feb 09 2021 22:56:29 GMT+0900 (대한민국 표준시)

/* Date 생성자의 인수로 날짜와 시간을 전달하면 그 날짜와 시간을 가리키는 Date 객체가 생성된다. */
var then = new Date(2021, 2, 9);
console.log(then);

/* Date 객체는 계산식 안에서 밀리초 단위 정수로 값으로 타입이 바뀐다. */
var elapsed = now - then;
console.log(elapsed);

/* 이 성질을 활용하면 프로그램 실행에 걸리는 시간을 밀리초 단위로 구할 수 있다 */
var start = new Date();
/* 실행 기간을 측정할 코드를 작성하는 위치 */
var end = new Date();
var elapsed = end - start;

/* Function은 함수를 생성하는 내장 생성자이다. 예를 들어  아까 등장한 함수 square는 다음과 같이 Function 생성자로 함수를 생성하도록 수정할 수 있다. */
var square = new Function("x", "return x*x");
/* 이때 첫 번째 인자인 "x" 는 인수의 이름을 뜻하는 문자열이고 두 번째 인수는 함수 몸통(function body)이 작성된 문자열입니다. 일반적으로 인수가 n개일 때는 다음과 같이 사용한다. */
/* var 변수 이름 = new Function(첫 번째 인수, ...., n번째 인수, 함수 몸통); */
/* 함수 생성자로 생성한 함수는 전역 변수와 자신의 지역 변수만 읽고 쓸 수 있다는 단점이 있어서 함수를 동적으로 생성해야 하는 특별한 상황 외에는 사용하지 않는다. */

/* 전역 객체는 자바스크립트에서 매우 중요한 객체라고 하네 뭐 나오겠지 */

