/* 입력 값을 받으면 출력 값으로 함수 값을 반환한다. 자바스크립트에서는 함수의 입력 값을 '인수'라고 부르고 함수의 출력 값을 '반환값' 이라고 부름. */
/* 변수 이름과 마찬가지로 모든 식별자를 함수 이름으로 사용할 수 있다. 그러나 함수 이름은 해당 함수의 기능을 이해하기 쉽게 지어야함 */
function square(x) {
  return x * x; // return문이 실행되면 호출한 코드로 돌아가고 return문의 값은 함수의 반환값이 된다. return문이 실행되지 않은 상태로 마지막 문장이 실행되면, 호출한 코드로 돌아간 후 undefined가 함수의 반환값이 된다.
}

square(3); //함수가 계산되어 9 를 출력. 인수로 넘긴 값인 3이 함수 정의문의 인수 x로 전달되고, 중괄호 안에 작성된 코드를 실행한다. 결과적으로 return문의 값인 9가 함수의 반환값이 되는데, 이때 함수를 호출할 때 전달하는 값을 '인수', 함수 정의문의 인수를 '인자' 라고 한다.

/* 함수는 인수를 여러 개 받을 수 있다. 인수가 여러 개라면 인수와 인수를 쉼표(,)로 구분한다. 예를 들어 다음 함수 dist는 두 점 사이의 거리를 구하는 함수이ㅏㄷ. 이때 전달하는 인수 p와 q는 좌표평면의 점 하나를 표현하는 객체이며, 각각의 객체는 {x:1, y:2} 라는 구조를 가지고있다. */
function dist(p, q) {
  var dx = q.x - p.x;
  var dy = q.y - p.y;
  return Math.sqrt(dx * dx + dy * dy); // Math.sqrt는 제곱근을 구하는 함수.
} // 뭔 개소리여 시벌

/* 함수의 흐름은 호출한 코드에 있는 인수가 함수 정의문의 인자에 대입된다. 함수 정의문의 중괄호 안에 작성된 프로그램이 순차적으로 실행된다. return문이 실행되면 호출한 코드로 돌아간다. return문의 값은 함수의 반환값이 된다. return문이 실행되지 않은 상태로 마지막 문장이 실행되면, 호출한 코드로 돌아간 후에 undefined가 함수의 반환값이 된다.*/

/* 자바스크립트 엔진은 변수 선언문과 마찬가지로 함수 선언문을 프로그램 첫머리로 호이스팅 하기 때문에 함수 선언문은 프로그램의 어떤 위치에도 작성할 수 있다. 예를 들어 다음과 같이 함수를 정의하기 전에 함수를 실행하는 코드를 작성해도 문제없이 동작한다.*/
console.log(square(5));
function square(x) {
  return x * x;
}

/* 자바스크립트에서는 함수가 객체이다. 함수 선언문으로 함수를 선언하면 내부적으로는 그 함수 이름을 변수 이름으로 한 변수와 함수 객체가 만들어지고, 그 변수에 함수 객체의 참조가 저장된다. */

var sq = square; //다른 변수에 함수를 할당하면 그 변수 이름으로 함수를 실행할 수 있다.
console.log(sq(5));

/* add1은 전달받은 인수에 1을 더하여 반환하는 함수이다. 이 함수가 호출될 때 변수 a의 복사본이 이 인자 x에 할당된다. 즉, 인수에 원시 값을 넘기면 그 값 자체가 인자에 전달된다. 이를 가리켜 '값의 전달' 이라고 부른다. 이때 변수 a와 변수 x는 다른 영역의 메모리에 위치한 별개의 변수이다. 따라서 x 값을 바꾸더라도 a 값은 바뀌지 않는다.*/
function add1(x) {
  return (x = x + 1);
}
var a = 3;
var b = add1(a);
console.log("a = " + a + ", b = " + b); // -> a = 3, b = 3

/* 함수가 호출될 때 변수 a의 복사본이 인자 p에 할당된다. 여기까지는 원시 값을 인수로 넘겼을 때와 동일하게 동작한다. 그러나 이전과 다르게 변수 a에 객체 {x : 3, y : 4}의 참조가 저장되어 있으며, 이 참조 값을 인자 p에 대입한다. 즉, 인수로 객체를 넘겼을 때 전달되는 값은 참조 값이다. 이를 가리켜 참조 전달이라 부른다. 이때 인자 p와 변수 a는 똑같은 객체를 참조하고 있다. 따라서 함수 안에서 p.x와 p.y를 수정하는 해우이는 a.x와 a.y를 수정하는 행위와 같다. */
function add1(p) {
  p.x = p.x + 1;
  p.y = p.y + 1;
  return p;
}
var a = { x: 3, Y: 4 };
var b = add1(a);
console.log(a, b); // -> Object {x=4, y=5}  Object {x=4, y=5}
/* 이처럼 함수의 인수로 객체를 넘기면 함수 안에서 원래의 객체를 바꿀 수 있다. */

/* 만약 함수에 인수 개수가 많아지면 함수의 인수를 객체의 프로퍼티에 담아서 함수에 넘기도록 하면 관리가 쉬워진다. */
function setBallProperties(x, y, vs, vy, radius) {}
setBallProperties(parameters); // 이렇게 되면 인수의 순서를 착각하기 쉽고 함수가 받는 개수를 바꾸면 함수의 호출 방법이 바뀌므로 프로그램 전체를 수정해야 한다.

var parameters = {
  x: 0,
  y: 0,
  vs: 10,
  vy: 15,
  radius: 5,
};
function setBallProperties(params) {}
setBallProperties(parameters);
/* 이때 함수 안에서 프로퍼티를 읽는 코드는 params.vs 처럼 표현하면 되므로 인수 순서가 바뀌는 문제가 발생하지 않는다. 또한 전달하는 인수를 추가하는 경우에도 프로퍼티만 추가하면 되므로 함수를 호출하는 방법을 바꿀 필요가 없다. */

/* 함수 안에서 변수를 선언하면 자바스크립트 엔진은 문장 순서와 관계 없이  호이스팅하여 함수의 첫머리로 끌어올린다 ****그러나 var문과 달리 var 문으로 선언한 변수를 끌어올리지 않는다.*** */
function f() {
  console.log(a); // -> undefined
  var a = "local";
  console.log(a); // -> local
  return a;
}

/* 함수 안에서 변수를 선언하지 않은 상태에서 값을 대입하면 전역 변수로 선언된다. 이 현상은 함수 바깥에서 발생하지만 함수 안에서도 발생한다. */
function y() {
  a = "local";
  console.log(a); // -> local
  return a;
}
y();
console.log(a); // -> local
/* 언뜻 보기에 변수 a는 함수 f의 지역 변수처럼 보이지만 var으로 선언하지 않았으므로 실제로는 전역 변수이다. 따라서 프로그램의 어느 위치에서도 사용할 수 있다.

/* 자바스크립트 엔진은 var와 달리 let문으로 선언한 변수를 호이스팅 하지 않는다 */
console.log(x); // -> ReferenceError:x is not defined
let x = 5;
/* 또한 let 문으로 똑같은 이름을 가진 변수를 선언하면 문법 오류가 발생한다. */
let x;
let x; // -> Uncaught SyntaxError

/* const 문은 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언한다. const로 선언한 상수는 let 문으로 선언한 변수처럼 동작한다. 단, 반드시 초기화 해야한다. */
const c = 2;
c = 4; // -> Uncaught TypeError    const로 선언된 상수에 다른 값을 대입하면 에러

/* const 문으로 선언한 상수 값은 수정할 수 없지만, 상수 값이 객체이거나 배열일 경우 프로퍼티 도는 프로퍼티 값을 수정할 수 있다 */
const origin = { x: 1, y: 3 };
origin.x = 3;
console.log(origin); // -> {x : 3, y : 3}

/* 함수는 함수 리터럴로도 정의할 수 있다. 예를 들어 앞에서 예로 들었던 함수 square는 다음과 같이 함수 리터럴로 수정할 수 있다 */
var square = function (x) {
  return x * x;
};
/* function(x) {...} 이 부분이 함루 시터럴이다. 함수 리터럴은 이름이 없는 함수이므로 익명 함수 또는 무명 함수라고 부른다. 기존 함수 선언문에서는 끝에 세미콜론을 붙일 필요가 없지만 함수 리터럴을 사용할 때는 끝에 반드시 세미콜론을 붙여야한다. 사용법은 함수 선언문과 같다. */

/* 함수 선언문으로 정의한 함수는 끌어올리지만 함수 리터럴로 정의한 함수는 끌어올리지 않는다. 함수 리터럴로 정의한 익명 함수는 변수에 할당한 후에야 비로소 square라는 이름을 갖게 되고, 그 이름을 호출할 수 있게 된다. 이러한 이유 때문에 함수를 정의하지 않은 상태에서 함수를 사용하려고 하면 타입 오류가 발생한다. */
console.log(square(3)); // -> TypeError:square is not a funtion
var square = function (x) {
  return x * x;
};

/*익명 함수에도 이름을 붙일 수 있다. */
var square = function sq(x) {
  return x * x;
};
/* 그러나 코드에서 sq라는 이름은 함수 안에서만 유효하므로 바깥에서는 sq라는 이름으로 함수를 호출할 수 없다. */

/* 함수 표현식으로 함수를 만들고, 객체 프로퍼티 user.sayHi에 함수를 할당하였다. 이제 객체에 할당된 함수를 호출하면 user가 인사를 해준다 */
var user = {
  name: "John",
  age: 30,
};
user.sayHi = function () {
  alert("안녕하세요");
};
user.sayHi();
/* 이렇게 객체 프로퍼티에 할당된 함수를 메서드(method)라고 부른다. 위 예시에선 user에 할당된 sayHi가 메서드 이다. */

/* 메서드는 아래와 같이 이미 정의된 함수를 이용해서 만들 수도 있다 */
var user = {
  name: "John",
  age: 30,
};
function sayHi() {
  alert("안녕하세요!");
}
user.sayHi = sayHi;
user.sayHi();

/* 메서드는 객체에 저장된 정보에 접근할 수 있어야 제 역할을 할 수 있다. 모든 메서드가 그런 건 아니지만, 대부분의 메서드가 객체 프로퍼티의 값을 활용한다. 메서드 내부에서 this 키워드를 사용하면 객체에 접근할 수 있다 */
var user = {
  name: "John",
  age: 30,
  sayHi() {
    alert(this.name);
  },
};
user.sayHi();
/* 함수 객체 안에 적힌 this는 그 함수를 메서드로 가지고 있는 객체를 가리킨다. 위 코드에서는 user를 가리킨다. 즉,this.name 이 user.name이다. 메서드는 일반 함수와 마찬가지로 소괄호를 붙여서 실행한다. 이때 점 앞의 this는 객체를 나타낸다. 정확히는 메서드를 호출할 때 사용된 객체를 나타낸다 */

